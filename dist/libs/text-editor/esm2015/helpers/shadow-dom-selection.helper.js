const debug = false;
const hasShadow = 'attachShadow' in Element.prototype && 'getRootNode' in Element.prototype;
const hasSelection = !!(hasShadow && document.createElement('div').attachShadow({ mode: 'open' }).getSelection);
const hasShady = window.ShadyDOM && window.ShadyDOM.inUse;
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ||
    /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const useDocument = !hasShadow || hasShady || (!hasSelection && !isSafari);
const validNodeTypes = [Node.ELEMENT_NODE, Node.TEXT_NODE, Node.DOCUMENT_FRAGMENT_NODE];
function isValidNode(node) {
    return validNodeTypes.includes(node.nodeType);
}
function findNode(s, parentNode, isLeft) {
    const nodes = parentNode.childNodes || parentNode.children;
    if (!nodes) {
        return parentNode; // found it, probably text
    }
    for (let i = 0; i < nodes.length; ++i) {
        const j = isLeft ? i : (nodes.length - 1 - i);
        const childNode = nodes[j];
        if (!isValidNode(childNode)) {
            continue;
        }
        debug && console.debug('checking child', childNode, 'IsLeft', isLeft);
        if (s.containsNode(childNode, true)) {
            if (s.containsNode(childNode, false)) {
                debug && console.info('found child', childNode);
                return childNode;
            }
            debug && console.info('descending child', childNode);
            return findNode(s, childNode, isLeft);
        }
        debug && console.info(parentNode, 'does NOT contain', childNode);
    }
    return parentNode;
}
const addInternalListener = (() => {
    if (hasSelection || useDocument) {
        // getSelection exists or document API can be used
        document.addEventListener('selectionchange', (ev) => {
            document.dispatchEvent(new CustomEvent('-shadow-selectionchange'));
        });
        return () => { };
    }
    let withinInternals = false;
    const handlers = [];
    document.addEventListener('selectionchange', (ev) => {
        if (withinInternals) {
            return;
        }
        document.dispatchEvent(new CustomEvent('-shadow-selectionchange'));
        withinInternals = true;
        window.setTimeout(() => {
            withinInternals = false;
        }, 0);
        handlers.forEach((fn) => fn(ev));
    });
    return (fn) => handlers.push(fn);
})();
let wasCaret = false;
let resolveTask = null;
addInternalListener((ev) => {
    const s = window.getSelection();
    if (s.type === 'Caret') {
        wasCaret = true;
    }
    else if (wasCaret && !resolveTask) {
        resolveTask = Promise.resolve(true).then(() => {
            wasCaret = false;
            resolveTask = null;
        });
    }
});
function containsNextElement(s, node, walkForward) {
    const start = node;
    while (node = walkFromNode(node, walkForward)) {
        // walking (left) can contain our own parent, which we don't want
        if (!node.contains(start)) {
            break;
        }
    }
    if (!node) {
        return false;
    }
    // we look for Element as .containsNode says true for _every_ text node, and we only care about
    // elements themselves
    return node instanceof Element && s.containsNode(node, true);
}
function getSelectionDirection(s, leftNode, rightNode) {
    if (s.type !== 'Range') {
        return undefined; // no direction
    }
    const measure = () => s.toString().length;
    const initialSize = measure();
    debug && console.info(`initial selection: "${s.toString()}"`);
    if (initialSize === 1 && wasCaret && leftNode === rightNode) {
        // nb. We need to reset a single selection as Safari _always_ tells us the cursor was dragged
        // left to right (maybe RTL on those devices).
        // To be fair, Chrome has the same bug.
        debug && console.debug('resetting size=1');
        s.extend(leftNode, 0);
        s.collapseToEnd();
        return undefined;
    }
    let updatedSize;
    // Try extending forward and seeing what happens.
    s.modify('extend', 'forward', 'character');
    updatedSize = measure();
    debug && console.info(`forward selection: "${s.toString()}"`);
    if (updatedSize > initialSize || containsNextElement(s, rightNode, true)) {
        debug && console.info('got forward >, moving right');
        s.modify('extend', 'backward', 'character');
        return true;
    }
    else if (updatedSize < initialSize || !s.containsNode(leftNode)) {
        debug && console.info('got forward <, moving left');
        s.modify('extend', 'backward', 'character');
        return false;
    }
    // Maybe we were at the end of something. Extend backwards.
    // TODO(samthor): We seem to be able to get away without the 'backwards' case.
    s.modify('extend', 'backward', 'character');
    updatedSize = measure();
    debug && console.info(`backward selection: "${s.toString()}"`);
    if (updatedSize > initialSize || containsNextElement(s, leftNode, false)) {
        debug && console.info('got backwards >, moving left');
        s.modify('extend', 'forward', 'character');
        return false;
    }
    else if (updatedSize < initialSize || !s.containsNode(rightNode)) {
        debug && console.info('got backwards <, moving right');
        s.modify('extend', 'forward', 'character');
        return true;
    }
    // This is likely a select-all.
    return undefined;
}
function walkFromNode(node, walkForward) {
    if (!walkForward) {
        return node.previousSibling || node.parentNode || null;
    }
    while (node) {
        if (node.nextSibling) {
            return node.nextSibling;
        }
        node = node.parentNode;
    }
    return null;
}
function walkTextFromNode(node, isLeft, s) {
    for (; node; node = walkFromNode(node, isLeft)) {
        if (node.nodeType !== Node.TEXT_NODE) {
            continue;
        }
        const t = node.textContent;
        if (isLeft) {
            if (s.length < t.length) {
                return { node, offset: s.length };
            }
            const prefix = s.substr(0, t.length);
            if (prefix !== t) {
                console.debug('unexpected string prefix', prefix, 'expected', t);
            }
            s = s.substr(t.length);
        }
        else {
            if (s.length < t.length) {
                return { node, offset: t.length - s.length };
            }
            const suffix = s.substr(s.length - t.length);
            if (suffix !== t) {
                console.debug('unexpected string suffix', suffix, 'expected', t);
            }
            s = s.substr(0, s.length - t.length);
        }
    }
    return null; // too far
}
function initialSpace(node) {
    if (node.nodeType !== Node.TEXT_NODE) {
        return 0;
    }
    return /^\s*/.exec(node.textContent)[0].length;
}
function ignoredTrailingSpace(node) {
    if (node.nodeType !== Node.TEXT_NODE) {
        return 0;
    }
    const trailingSpaceCount = /\s*$/.exec(node.textContent)[0].length;
    if (!trailingSpaceCount) {
        return 0;
    }
    return trailingSpaceCount - 1; // always allow single last
}
const cachedRange = new Map();
export function getRange(root) {
    if (hasSelection || useDocument) {
        const s = (useDocument ? document : root).getSelection();
        return s.rangeCount ? s.getRangeAt(0) : null;
    }
    const thisFrame = cachedRange.get(root);
    if (thisFrame) {
        return thisFrame;
    }
    const initialText = window.getSelection().toString();
    const result = internalGetShadowSelection(root);
    const rs = result.range && result.range.toString() || null;
    if (rs !== null && rs !== initialText) {
        // TODO: sometimes triggers on single-char hack etc
        if (rs.replace(/\s/g, '') !== initialText.replace(/\s/g, '')) {
            // nb. selection eats initial/ending space, range does not: if whitespace is the only
            // difference, then ignore
            console.warn('invalid range, initial text:', initialText);
            console.warn('vs', rs, result.mode, result.range);
        }
    }
    cachedRange.set(root, result.range);
    window.setTimeout(() => {
        cachedRange.delete(root);
    }, 0);
    debug && console.debug('getRange got', result);
    return result.range;
}
const fakeSelectionNode = document.createTextNode('');
export function internalGetShadowSelection(root) {
    const range = document.createRange();
    const s = window.getSelection();
    // if (!s.containsNode(root.host, true)) {
    //   return {range: null, mode: 'none'};
    // }
    // TODO: inserting fake nodes isn't ideal, but containsNode doesn't work on nearby adjacent
    // text nodes (in fact it returns true for all text nodes on the page?!).
    // insert a fake 'before' node to see if it's selected
    root.insertBefore(fakeSelectionNode, root.childNodes[0]);
    const includesBeforeRoot = s.containsNode(fakeSelectionNode);
    fakeSelectionNode.remove();
    if (includesBeforeRoot) {
        return { range: null, mode: 'outside-before' };
    }
    // insert a fake 'after' node to see if it's selected
    root.appendChild(fakeSelectionNode);
    const includesAfterRoot = s.containsNode(fakeSelectionNode);
    fakeSelectionNode.remove();
    if (includesAfterRoot) {
        return { range: null, mode: 'outside-after' };
    }
    const measure = () => s.toString().length;
    const initialSelectionContent = s.toString();
    if (!(s.type === 'Caret' || s.type === 'Range')) {
        return { range: null, mode: 'outside-after' };
    }
    const initialCaret = (s.type === 'Caret');
    const leftNode = findNode(s, root, true);
    let rightNode;
    let isNaturalDirection = undefined;
    if (s.type === 'Range') {
        rightNode = findNode(s, root, false); // get right node here _before_ getSelectionDirection
        isNaturalDirection = getSelectionDirection(s, leftNode, rightNode);
        // isNaturalDirection means "going right"
    }
    if (s.type === 'Caret') {
        // we might transition to being a caret, so don't check initial value
        s.extend(leftNode, 0);
        const at = measure();
        s.collapseToEnd();
        range.setStart(leftNode, at);
        range.setEnd(leftNode, at);
        return { range, mode: 'caret' };
    }
    else if (isNaturalDirection === undefined) {
        if (s.type !== 'Range') {
            throw new TypeError('unexpected type: ' + s.type);
        }
        // This occurs when we can't move because we can't extend left or right to measure the
        // direction we're moving in. Good news though: we don't need to _change_ the selection
        // to measure it, so just return immediately.
        range.setStart(leftNode, 0);
        range.setEnd(rightNode, rightNode.length);
        return { range, mode: 'all' };
    }
    const size = measure();
    let offsetLeft, offsetRight;
    // only one newline/space char is cared about
    const validRightLength = rightNode.length - ignoredTrailingSpace(rightNode);
    if (isNaturalDirection) {
        // walk in the opposite direction first
        s.extend(leftNode, 0);
        offsetLeft = measure() + initialSpace(leftNode); // measure doesn't include initial space
        // then in our actual direction
        s.extend(rightNode, validRightLength);
        offsetRight = validRightLength - (measure() - size);
        // then revert to the original position
        s.extend(rightNode, offsetRight);
    }
    else {
        // walk in the opposite direction first
        s.extend(rightNode, validRightLength);
        offsetRight = validRightLength - measure();
        // then in our actual direction
        s.extend(leftNode, 0);
        offsetLeft = measure() - size + initialSpace(leftNode); // doesn't include initial space
        // then revert to the original position
        s.extend(leftNode, offsetLeft);
    }
    if (debug) {
        if (leftNode === rightNode) {
            console.info('got string', leftNode.textContent.substr(offsetLeft, offsetRight - offsetLeft));
        }
        else {
            console.info('>>> string', leftNode.textContent.substr(offsetLeft));
            console.info('<<< string', rightNode.textContent.substr(0, offsetRight));
        }
    }
    range.setStart(leftNode, offsetLeft);
    range.setEnd(rightNode, offsetRight);
    return {
        mode: isNaturalDirection ? 'right' : 'left',
        range,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZG93LWRvbS1zZWxlY3Rpb24uaGVscGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHBlL2J1aWxkZXItdGV4dC1lZGl0b3IvIiwic291cmNlcyI6WyJoZWxwZXJzL3NoYWRvdy1kb20tc2VsZWN0aW9uLmhlbHBlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUM7QUFFcEIsTUFBTSxTQUFTLEdBQUcsY0FBYyxJQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksYUFBYSxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUM7QUFDNUYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxJQUFJLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDaEgsTUFBTSxRQUFRLEdBQUksTUFBYyxDQUFDLFFBQVEsSUFBSyxNQUFjLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztBQUM1RSxNQUFNLFFBQVEsR0FBRyxnQ0FBZ0MsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQztJQUN6RSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUUsTUFBYyxDQUFDLFFBQVEsQ0FBQztBQUM1RSxNQUFNLFdBQVcsR0FBRyxDQUFDLFNBQVMsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBRTNFLE1BQU0sY0FBYyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQ3hGLFNBQVMsV0FBVyxDQUFDLElBQUk7SUFDdkIsT0FBTyxjQUFjLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztB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QUFDLENBQUMsQ0FBQztTQUMxRTtLQUNGO0lBRUQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDckMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsT0FBTztRQUNMLElBQUksRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNO1FBQzNDLEtBQUs7S0FDTixDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlYnVnID0gZmFsc2U7XG5cbmNvbnN0IGhhc1NoYWRvdyA9ICdhdHRhY2hTaGFkb3cnIGluIEVsZW1lbnQucHJvdG90eXBlICYmICdnZXRSb290Tm9kZScgaW4gRWxlbWVudC5wcm90b3R5cGU7XG5jb25zdCBoYXNTZWxlY3Rpb24gPSAhIShoYXNTaGFkb3cgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pLmdldFNlbGVjdGlvbik7XG5jb25zdCBoYXNTaGFkeSA9ICh3aW5kb3cgYXMgYW55KS5TaGFkeURPTSAmJiAod2luZG93IGFzIGFueSkuU2hhZHlET00uaW5Vc2U7XG5jb25zdCBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgISh3aW5kb3cgYXMgYW55KS5NU1N0cmVhbTtcbmNvbnN0IHVzZURvY3VtZW50ID0gIWhhc1NoYWRvdyB8fCBoYXNTaGFkeSB8fCAoIWhhc1NlbGVjdGlvbiAmJiAhaXNTYWZhcmkpO1xuXG5jb25zdCB2YWxpZE5vZGVUeXBlcyA9IFtOb2RlLkVMRU1FTlRfTk9ERSwgTm9kZS5URVhUX05PREUsIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERV07XG5mdW5jdGlvbiBpc1ZhbGlkTm9kZShub2RlKSB7XG4gIHJldHVybiB2YWxpZE5vZGVUeXBlcy5pbmNsdWRlcyhub2RlLm5vZGVUeXBlKTtcbn1cblxuZnVuY3Rpb24gZmluZE5vZGUocywgcGFyZW50Tm9kZSwgaXNMZWZ0KSB7XG4gIGNvbnN0IG5vZGVzID0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzIHx8IHBhcmVudE5vZGUuY2hpbGRyZW47XG4gIGlmICghbm9kZXMpIHtcbiAgICByZXR1cm4gcGFyZW50Tm9kZTsgIC8vIGZvdW5kIGl0LCBwcm9iYWJseSB0ZXh0XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgaiA9IGlzTGVmdCA/IGkgOiAobm9kZXMubGVuZ3RoIC0gMSAtIGkpO1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGVzW2pdO1xuICAgIGlmICghaXNWYWxpZE5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZGVidWcgJiYgY29uc29sZS5kZWJ1ZygnY2hlY2tpbmcgY2hpbGQnLCBjaGlsZE5vZGUsICdJc0xlZnQnLCBpc0xlZnQpO1xuICAgIGlmIChzLmNvbnRhaW5zTm9kZShjaGlsZE5vZGUsIHRydWUpKSB7XG4gICAgICBpZiAocy5jb250YWluc05vZGUoY2hpbGROb2RlLCBmYWxzZSkpIHtcbiAgICAgICAgZGVidWcgJiYgY29uc29sZS5pbmZvKCdmb3VuZCBjaGlsZCcsIGNoaWxkTm9kZSk7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICB9XG4gICAgICBkZWJ1ZyAmJiBjb25zb2xlLmluZm8oJ2Rlc2NlbmRpbmcgY2hpbGQnLCBjaGlsZE5vZGUpO1xuICAgICAgcmV0dXJuIGZpbmROb2RlKHMsIGNoaWxkTm9kZSwgaXNMZWZ0KTtcbiAgICB9XG4gICAgZGVidWcgJiYgY29uc29sZS5pbmZvKHBhcmVudE5vZGUsICdkb2VzIE5PVCBjb250YWluJywgY2hpbGROb2RlKTtcbiAgfVxuICByZXR1cm4gcGFyZW50Tm9kZTtcbn1cblxuY29uc3QgYWRkSW50ZXJuYWxMaXN0ZW5lciA9ICgoKSA9PiB7XG4gIGlmIChoYXNTZWxlY3Rpb24gfHwgdXNlRG9jdW1lbnQpIHtcbiAgICAvLyBnZXRTZWxlY3Rpb24gZXhpc3RzIG9yIGRvY3VtZW50IEFQSSBjYW4gYmUgdXNlZFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIChldikgPT4ge1xuICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJy1zaGFkb3ctc2VsZWN0aW9uY2hhbmdlJykpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7fTtcbiAgfVxuXG4gIGxldCB3aXRoaW5JbnRlcm5hbHMgPSBmYWxzZTtcbiAgY29uc3QgaGFuZGxlcnMgPSBbXTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCAoZXYpID0+IHtcbiAgICBpZiAod2l0aGluSW50ZXJuYWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCctc2hhZG93LXNlbGVjdGlvbmNoYW5nZScpKTtcbiAgICB3aXRoaW5JbnRlcm5hbHMgPSB0cnVlO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHdpdGhpbkludGVybmFscyA9IGZhbHNlO1xuICAgIH0sIDApO1xuICAgIGhhbmRsZXJzLmZvckVhY2goKGZuKSA9PiBmbihldikpO1xuICB9KTtcblxuICByZXR1cm4gKGZuKSA9PiBoYW5kbGVycy5wdXNoKGZuKTtcbn0pKCk7XG5cbmxldCB3YXNDYXJldCA9IGZhbHNlO1xubGV0IHJlc29sdmVUYXNrID0gbnVsbDtcbmFkZEludGVybmFsTGlzdGVuZXIoKGV2KSA9PiB7XG4gIGNvbnN0IHMgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChzLnR5cGUgPT09ICdDYXJldCcpIHtcbiAgICB3YXNDYXJldCA9IHRydWU7XG4gIH0gZWxzZSBpZiAod2FzQ2FyZXQgJiYgIXJlc29sdmVUYXNrKSB7XG4gICAgcmVzb2x2ZVRhc2sgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICB3YXNDYXJldCA9IGZhbHNlO1xuICAgICAgcmVzb2x2ZVRhc2sgPSBudWxsO1xuICAgIH0pO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY29udGFpbnNOZXh0RWxlbWVudChzLCBub2RlLCB3YWxrRm9yd2FyZCkge1xuICBjb25zdCBzdGFydCA9IG5vZGU7XG4gIHdoaWxlIChub2RlID0gd2Fsa0Zyb21Ob2RlKG5vZGUsIHdhbGtGb3J3YXJkKSkge1xuICAgIC8vIHdhbGtpbmcgKGxlZnQpIGNhbiBjb250YWluIG91ciBvd24gcGFyZW50LCB3aGljaCB3ZSBkb24ndCB3YW50XG4gICAgaWYgKCFub2RlLmNvbnRhaW5zKHN0YXJ0KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyB3ZSBsb29rIGZvciBFbGVtZW50IGFzIC5jb250YWluc05vZGUgc2F5cyB0cnVlIGZvciBfZXZlcnlfIHRleHQgbm9kZSwgYW5kIHdlIG9ubHkgY2FyZSBhYm91dFxuICAvLyBlbGVtZW50cyB0aGVtc2VsdmVzXG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBzLmNvbnRhaW5zTm9kZShub2RlLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRGlyZWN0aW9uKHMsIGxlZnROb2RlLCByaWdodE5vZGUpIHtcbiAgaWYgKHMudHlwZSAhPT0gJ1JhbmdlJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7ICAvLyBubyBkaXJlY3Rpb25cbiAgfVxuICBjb25zdCBtZWFzdXJlID0gKCkgPT4gcy50b1N0cmluZygpLmxlbmd0aDtcblxuICBjb25zdCBpbml0aWFsU2l6ZSA9IG1lYXN1cmUoKTtcbiAgZGVidWcgJiYgY29uc29sZS5pbmZvKGBpbml0aWFsIHNlbGVjdGlvbjogXCIke3MudG9TdHJpbmcoKX1cImApXG5cbiAgaWYgKGluaXRpYWxTaXplID09PSAxICYmIHdhc0NhcmV0ICYmIGxlZnROb2RlID09PSByaWdodE5vZGUpIHtcbiAgICAvLyBuYi4gV2UgbmVlZCB0byByZXNldCBhIHNpbmdsZSBzZWxlY3Rpb24gYXMgU2FmYXJpIF9hbHdheXNfIHRlbGxzIHVzIHRoZSBjdXJzb3Igd2FzIGRyYWdnZWRcbiAgICAvLyBsZWZ0IHRvIHJpZ2h0IChtYXliZSBSVEwgb24gdGhvc2UgZGV2aWNlcykuXG4gICAgLy8gVG8gYmUgZmFpciwgQ2hyb21lIGhhcyB0aGUgc2FtZSBidWcuXG4gICAgZGVidWcgJiYgY29uc29sZS5kZWJ1ZygncmVzZXR0aW5nIHNpemU9MScpO1xuICAgIHMuZXh0ZW5kKGxlZnROb2RlLCAwKTtcbiAgICBzLmNvbGxhcHNlVG9FbmQoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGV0IHVwZGF0ZWRTaXplO1xuXG4gIC8vIFRyeSBleHRlbmRpbmcgZm9yd2FyZCBhbmQgc2VlaW5nIHdoYXQgaGFwcGVucy5cbiAgcy5tb2RpZnkoJ2V4dGVuZCcsICdmb3J3YXJkJywgJ2NoYXJhY3RlcicpO1xuICB1cGRhdGVkU2l6ZSA9IG1lYXN1cmUoKTtcbiAgZGVidWcgJiYgY29uc29sZS5pbmZvKGBmb3J3YXJkIHNlbGVjdGlvbjogXCIke3MudG9TdHJpbmcoKX1cImApXG5cbiAgaWYgKHVwZGF0ZWRTaXplID4gaW5pdGlhbFNpemUgfHwgY29udGFpbnNOZXh0RWxlbWVudChzLCByaWdodE5vZGUsIHRydWUpKSB7XG4gICAgZGVidWcgJiYgY29uc29sZS5pbmZvKCdnb3QgZm9yd2FyZCA+LCBtb3ZpbmcgcmlnaHQnKVxuICAgIHMubW9kaWZ5KCdleHRlbmQnLCAnYmFja3dhcmQnLCAnY2hhcmFjdGVyJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodXBkYXRlZFNpemUgPCBpbml0aWFsU2l6ZSB8fCAhcy5jb250YWluc05vZGUobGVmdE5vZGUpKSB7XG4gICAgZGVidWcgJiYgY29uc29sZS5pbmZvKCdnb3QgZm9yd2FyZCA8LCBtb3ZpbmcgbGVmdCcpXG4gICAgcy5tb2RpZnkoJ2V4dGVuZCcsICdiYWNrd2FyZCcsICdjaGFyYWN0ZXInKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNYXliZSB3ZSB3ZXJlIGF0IHRoZSBlbmQgb2Ygc29tZXRoaW5nLiBFeHRlbmQgYmFja3dhcmRzLlxuICAvLyBUT0RPKHNhbXRob3IpOiBXZSBzZWVtIHRvIGJlIGFibGUgdG8gZ2V0IGF3YXkgd2l0aG91dCB0aGUgJ2JhY2t3YXJkcycgY2FzZS5cbiAgcy5tb2RpZnkoJ2V4dGVuZCcsICdiYWNrd2FyZCcsICdjaGFyYWN0ZXInKTtcbiAgdXBkYXRlZFNpemUgPSBtZWFzdXJlKCk7XG4gIGRlYnVnICYmIGNvbnNvbGUuaW5mbyhgYmFja3dhcmQgc2VsZWN0aW9uOiBcIiR7cy50b1N0cmluZygpfVwiYClcblxuICBpZiAodXBkYXRlZFNpemUgPiBpbml0aWFsU2l6ZSB8fCBjb250YWluc05leHRFbGVtZW50KHMsIGxlZnROb2RlLCBmYWxzZSkpIHtcbiAgICBkZWJ1ZyAmJiBjb25zb2xlLmluZm8oJ2dvdCBiYWNrd2FyZHMgPiwgbW92aW5nIGxlZnQnKVxuICAgIHMubW9kaWZ5KCdleHRlbmQnLCAnZm9yd2FyZCcsICdjaGFyYWN0ZXInKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAodXBkYXRlZFNpemUgPCBpbml0aWFsU2l6ZSB8fCAhcy5jb250YWluc05vZGUocmlnaHROb2RlKSkge1xuICAgIGRlYnVnICYmIGNvbnNvbGUuaW5mbygnZ290IGJhY2t3YXJkcyA8LCBtb3ZpbmcgcmlnaHQnKVxuICAgIHMubW9kaWZ5KCdleHRlbmQnLCAnZm9yd2FyZCcsICdjaGFyYWN0ZXInKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgbGlrZWx5IGEgc2VsZWN0LWFsbC5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2Fsa0Zyb21Ob2RlKG5vZGUsIHdhbGtGb3J3YXJkKSB7XG4gIGlmICghd2Fsa0ZvcndhcmQpIHtcbiAgICByZXR1cm4gbm9kZS5wcmV2aW91c1NpYmxpbmcgfHwgbm9kZS5wYXJlbnROb2RlIHx8IG51bGw7XG4gIH1cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHdhbGtUZXh0RnJvbU5vZGUobm9kZSwgaXNMZWZ0LCBzKSB7XG4gIGZvciAoOyBub2RlOyBub2RlID0gd2Fsa0Zyb21Ob2RlKG5vZGUsIGlzTGVmdCkpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgIGlmIChpc0xlZnQpIHtcbiAgICAgIGlmIChzLmxlbmd0aCA8IHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7bm9kZSwgb2Zmc2V0OiBzLmxlbmd0aH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZWZpeCA9IHMuc3Vic3RyKDAsIHQubGVuZ3RoKTtcbiAgICAgIGlmIChwcmVmaXggIT09IHQpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygndW5leHBlY3RlZCBzdHJpbmcgcHJlZml4JywgcHJlZml4LCAnZXhwZWN0ZWQnLCB0KVxuICAgICAgfVxuXG4gICAgICBzID0gcy5zdWJzdHIodC5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy5sZW5ndGggPCB0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge25vZGUsIG9mZnNldDogdC5sZW5ndGggLSBzLmxlbmd0aH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN1ZmZpeCA9IHMuc3Vic3RyKHMubGVuZ3RoIC0gdC5sZW5ndGgpO1xuICAgICAgaWYgKHN1ZmZpeCAhPT0gdCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCd1bmV4cGVjdGVkIHN0cmluZyBzdWZmaXgnLCBzdWZmaXgsICdleHBlY3RlZCcsIHQpXG4gICAgICB9XG5cbiAgICAgIHMgPSBzLnN1YnN0cigwLCBzLmxlbmd0aCAtIHQubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDsgIC8vIHRvbyBmYXJcbn1cblxuZnVuY3Rpb24gaW5pdGlhbFNwYWNlKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIC9eXFxzKi8uZXhlYyhub2RlLnRleHRDb250ZW50KVswXS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRUcmFpbGluZ1NwYWNlKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgdHJhaWxpbmdTcGFjZUNvdW50ID0gIC9cXHMqJC8uZXhlYyhub2RlLnRleHRDb250ZW50KVswXS5sZW5ndGg7XG4gIGlmICghdHJhaWxpbmdTcGFjZUNvdW50KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRyYWlsaW5nU3BhY2VDb3VudCAtIDE7ICAvLyBhbHdheXMgYWxsb3cgc2luZ2xlIGxhc3Rcbn1cblxuY29uc3QgY2FjaGVkUmFuZ2UgPSBuZXcgTWFwKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2Uocm9vdCk6IFJhbmdlIHtcbiAgaWYgKGhhc1NlbGVjdGlvbiB8fCB1c2VEb2N1bWVudCkge1xuICAgIGNvbnN0IHMgPSAodXNlRG9jdW1lbnQgPyBkb2N1bWVudCA6IHJvb3QpLmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBzLnJhbmdlQ291bnQgPyBzLmdldFJhbmdlQXQoMCkgOiBudWxsO1xuICB9XG5cblxuICBjb25zdCB0aGlzRnJhbWUgPSBjYWNoZWRSYW5nZS5nZXQocm9vdCk7XG4gIGlmICh0aGlzRnJhbWUpIHtcbiAgICByZXR1cm4gdGhpc0ZyYW1lO1xuICB9XG5cbiAgY29uc3QgaW5pdGlhbFRleHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKTtcbiAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxHZXRTaGFkb3dTZWxlY3Rpb24ocm9vdCk7XG4gIGNvbnN0IHJzID0gcmVzdWx0LnJhbmdlICYmIHJlc3VsdC5yYW5nZS50b1N0cmluZygpIHx8IG51bGw7XG4gIGlmIChycyAhPT0gbnVsbCAmJiBycyAhPT0gaW5pdGlhbFRleHQpIHtcbiAgICAvLyBUT0RPOiBzb21ldGltZXMgdHJpZ2dlcnMgb24gc2luZ2xlLWNoYXIgaGFjayBldGNcblxuICAgIGlmIChycy5yZXBsYWNlKC9cXHMvZywgJycpICE9PSBpbml0aWFsVGV4dC5yZXBsYWNlKC9cXHMvZywgJycpKSB7XG4gICAgICAvLyBuYi4gc2VsZWN0aW9uIGVhdHMgaW5pdGlhbC9lbmRpbmcgc3BhY2UsIHJhbmdlIGRvZXMgbm90OiBpZiB3aGl0ZXNwYWNlIGlzIHRoZSBvbmx5XG4gICAgICAvLyBkaWZmZXJlbmNlLCB0aGVuIGlnbm9yZVxuICAgICAgY29uc29sZS53YXJuKCdpbnZhbGlkIHJhbmdlLCBpbml0aWFsIHRleHQ6JywgaW5pdGlhbFRleHQpO1xuICAgICAgY29uc29sZS53YXJuKCd2cycsIHJzLCByZXN1bHQubW9kZSwgcmVzdWx0LnJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBjYWNoZWRSYW5nZS5zZXQocm9vdCwgcmVzdWx0LnJhbmdlKTtcbiAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNhY2hlZFJhbmdlLmRlbGV0ZShyb290KTtcbiAgfSwgMCk7XG4gIGRlYnVnICYmIGNvbnNvbGUuZGVidWcoJ2dldFJhbmdlIGdvdCcsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdC5yYW5nZTtcbn1cblxuY29uc3QgZmFrZVNlbGVjdGlvbk5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuYWxHZXRTaGFkb3dTZWxlY3Rpb24ocm9vdCkge1xuICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgY29uc3QgcyA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgLy8gaWYgKCFzLmNvbnRhaW5zTm9kZShyb290Lmhvc3QsIHRydWUpKSB7XG4gIC8vICAgcmV0dXJuIHtyYW5nZTogbnVsbCwgbW9kZTogJ25vbmUnfTtcbiAgLy8gfVxuXG4gIC8vIFRPRE86IGluc2VydGluZyBmYWtlIG5vZGVzIGlzbid0IGlkZWFsLCBidXQgY29udGFpbnNOb2RlIGRvZXNuJ3Qgd29yayBvbiBuZWFyYnkgYWRqYWNlbnRcbiAgLy8gdGV4dCBub2RlcyAoaW4gZmFjdCBpdCByZXR1cm5zIHRydWUgZm9yIGFsbCB0ZXh0IG5vZGVzIG9uIHRoZSBwYWdlPyEpLlxuXG4gIC8vIGluc2VydCBhIGZha2UgJ2JlZm9yZScgbm9kZSB0byBzZWUgaWYgaXQncyBzZWxlY3RlZFxuICByb290Lmluc2VydEJlZm9yZShmYWtlU2VsZWN0aW9uTm9kZSwgcm9vdC5jaGlsZE5vZGVzWzBdKTtcbiAgY29uc3QgaW5jbHVkZXNCZWZvcmVSb290ID0gcy5jb250YWluc05vZGUoZmFrZVNlbGVjdGlvbk5vZGUpO1xuICBmYWtlU2VsZWN0aW9uTm9kZS5yZW1vdmUoKTtcbiAgaWYgKGluY2x1ZGVzQmVmb3JlUm9vdCkge1xuICAgIHJldHVybiB7cmFuZ2U6IG51bGwsIG1vZGU6ICdvdXRzaWRlLWJlZm9yZSd9O1xuICB9XG5cbiAgLy8gaW5zZXJ0IGEgZmFrZSAnYWZ0ZXInIG5vZGUgdG8gc2VlIGlmIGl0J3Mgc2VsZWN0ZWRcbiAgcm9vdC5hcHBlbmRDaGlsZChmYWtlU2VsZWN0aW9uTm9kZSk7XG4gIGNvbnN0IGluY2x1ZGVzQWZ0ZXJSb290ID0gcy5jb250YWluc05vZGUoZmFrZVNlbGVjdGlvbk5vZGUpO1xuICBmYWtlU2VsZWN0aW9uTm9kZS5yZW1vdmUoKTtcbiAgaWYgKGluY2x1ZGVzQWZ0ZXJSb290KSB7XG4gICAgcmV0dXJuIHtyYW5nZTogbnVsbCwgbW9kZTogJ291dHNpZGUtYWZ0ZXInfTtcbiAgfVxuXG4gIGNvbnN0IG1lYXN1cmUgPSAoKSA9PiBzLnRvU3RyaW5nKCkubGVuZ3RoO1xuICBjb25zdCBpbml0aWFsU2VsZWN0aW9uQ29udGVudCA9IHMudG9TdHJpbmcoKTtcbiAgaWYgKCEocy50eXBlID09PSAnQ2FyZXQnIHx8IHMudHlwZSA9PT0gJ1JhbmdlJykpIHtcbiAgICByZXR1cm4ge3JhbmdlOiBudWxsLCBtb2RlOiAnb3V0c2lkZS1hZnRlcid9O1xuICB9XG4gIGNvbnN0IGluaXRpYWxDYXJldCA9IChzLnR5cGUgPT09ICdDYXJldCcpO1xuXG4gIGNvbnN0IGxlZnROb2RlID0gZmluZE5vZGUocywgcm9vdCwgdHJ1ZSk7XG4gIGxldCByaWdodE5vZGU7XG4gIGxldCBpc05hdHVyYWxEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gIGlmIChzLnR5cGUgPT09ICdSYW5nZScpIHtcbiAgICByaWdodE5vZGUgPSBmaW5kTm9kZShzLCByb290LCBmYWxzZSk7ICAvLyBnZXQgcmlnaHQgbm9kZSBoZXJlIF9iZWZvcmVfIGdldFNlbGVjdGlvbkRpcmVjdGlvblxuICAgIGlzTmF0dXJhbERpcmVjdGlvbiA9IGdldFNlbGVjdGlvbkRpcmVjdGlvbihzLCBsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcbiAgICAvLyBpc05hdHVyYWxEaXJlY3Rpb24gbWVhbnMgXCJnb2luZyByaWdodFwiXG4gIH1cblxuICBpZiAocy50eXBlID09PSAnQ2FyZXQnKSB7XG4gICAgLy8gd2UgbWlnaHQgdHJhbnNpdGlvbiB0byBiZWluZyBhIGNhcmV0LCBzbyBkb24ndCBjaGVjayBpbml0aWFsIHZhbHVlXG4gICAgcy5leHRlbmQobGVmdE5vZGUsIDApO1xuICAgIGNvbnN0IGF0ID0gbWVhc3VyZSgpO1xuICAgIHMuY29sbGFwc2VUb0VuZCgpO1xuXG4gICAgcmFuZ2Uuc2V0U3RhcnQobGVmdE5vZGUsIGF0KTtcbiAgICByYW5nZS5zZXRFbmQobGVmdE5vZGUsIGF0KTtcbiAgICByZXR1cm4ge3JhbmdlLCBtb2RlOiAnY2FyZXQnfTtcbiAgfSBlbHNlIGlmIChpc05hdHVyYWxEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzLnR5cGUgIT09ICdSYW5nZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgdHlwZTogJyArIHMudHlwZSk7XG4gICAgfVxuICAgIC8vIFRoaXMgb2NjdXJzIHdoZW4gd2UgY2FuJ3QgbW92ZSBiZWNhdXNlIHdlIGNhbid0IGV4dGVuZCBsZWZ0IG9yIHJpZ2h0IHRvIG1lYXN1cmUgdGhlXG4gICAgLy8gZGlyZWN0aW9uIHdlJ3JlIG1vdmluZyBpbi4gR29vZCBuZXdzIHRob3VnaDogd2UgZG9uJ3QgbmVlZCB0byBfY2hhbmdlXyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gdG8gbWVhc3VyZSBpdCwgc28ganVzdCByZXR1cm4gaW1tZWRpYXRlbHkuXG4gICAgcmFuZ2Uuc2V0U3RhcnQobGVmdE5vZGUsIDApO1xuICAgIHJhbmdlLnNldEVuZChyaWdodE5vZGUsIHJpZ2h0Tm9kZS5sZW5ndGgpO1xuICAgIHJldHVybiB7cmFuZ2UsIG1vZGU6ICdhbGwnfTtcbiAgfVxuXG4gIGNvbnN0IHNpemUgPSBtZWFzdXJlKCk7XG4gIGxldCBvZmZzZXRMZWZ0LCBvZmZzZXRSaWdodDtcblxuLy8gb25seSBvbmUgbmV3bGluZS9zcGFjZSBjaGFyIGlzIGNhcmVkIGFib3V0XG4gIGNvbnN0IHZhbGlkUmlnaHRMZW5ndGggPSByaWdodE5vZGUubGVuZ3RoIC0gaWdub3JlZFRyYWlsaW5nU3BhY2UocmlnaHROb2RlKTtcblxuICBpZiAoaXNOYXR1cmFsRGlyZWN0aW9uKSB7XG4gICAgLy8gd2FsayBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGZpcnN0XG4gICAgcy5leHRlbmQobGVmdE5vZGUsIDApO1xuICAgIG9mZnNldExlZnQgPSBtZWFzdXJlKCkgKyBpbml0aWFsU3BhY2UobGVmdE5vZGUpOyAgLy8gbWVhc3VyZSBkb2Vzbid0IGluY2x1ZGUgaW5pdGlhbCBzcGFjZVxuXG4gICAgLy8gdGhlbiBpbiBvdXIgYWN0dWFsIGRpcmVjdGlvblxuICAgIHMuZXh0ZW5kKHJpZ2h0Tm9kZSwgdmFsaWRSaWdodExlbmd0aCk7XG4gICAgb2Zmc2V0UmlnaHQgPSB2YWxpZFJpZ2h0TGVuZ3RoIC0gKG1lYXN1cmUoKSAtIHNpemUpO1xuXG4gICAgLy8gdGhlbiByZXZlcnQgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgcy5leHRlbmQocmlnaHROb2RlLCBvZmZzZXRSaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2FsayBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGZpcnN0XG4gICAgcy5leHRlbmQocmlnaHROb2RlLCB2YWxpZFJpZ2h0TGVuZ3RoKTtcbiAgICBvZmZzZXRSaWdodCA9IHZhbGlkUmlnaHRMZW5ndGggLSBtZWFzdXJlKCk7XG5cbiAgICAvLyB0aGVuIGluIG91ciBhY3R1YWwgZGlyZWN0aW9uXG4gICAgcy5leHRlbmQobGVmdE5vZGUsIDApO1xuICAgIG9mZnNldExlZnQgPSBtZWFzdXJlKCkgLSBzaXplICsgaW5pdGlhbFNwYWNlKGxlZnROb2RlKTsgIC8vIGRvZXNuJ3QgaW5jbHVkZSBpbml0aWFsIHNwYWNlXG5cbiAgICAvLyB0aGVuIHJldmVydCB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb25cbiAgICBzLmV4dGVuZChsZWZ0Tm9kZSwgb2Zmc2V0TGVmdCk7XG4gIH1cblxuICBpZiAoZGVidWcpIHtcbiAgICBpZiAobGVmdE5vZGUgPT09IHJpZ2h0Tm9kZSkge1xuICAgICAgY29uc29sZS5pbmZvKCdnb3Qgc3RyaW5nJywgbGVmdE5vZGUudGV4dENvbnRlbnQuc3Vic3RyKG9mZnNldExlZnQsIG9mZnNldFJpZ2h0IC0gb2Zmc2V0TGVmdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmluZm8oJz4+PiBzdHJpbmcnLCBsZWZ0Tm9kZS50ZXh0Q29udGVudC5zdWJzdHIob2Zmc2V0TGVmdCkpO1xuICAgICAgY29uc29sZS5pbmZvKCc8PDwgc3RyaW5nJywgcmlnaHROb2RlLnRleHRDb250ZW50LnN1YnN0cigwLCBvZmZzZXRSaWdodCkpO1xuICAgIH1cbiAgfVxuXG4gIHJhbmdlLnNldFN0YXJ0KGxlZnROb2RlLCBvZmZzZXRMZWZ0KTtcbiAgcmFuZ2Uuc2V0RW5kKHJpZ2h0Tm9kZSwgb2Zmc2V0UmlnaHQpO1xuICByZXR1cm4ge1xuICAgIG1vZGU6IGlzTmF0dXJhbERpcmVjdGlvbiA/ICdyaWdodCcgOiAnbGVmdCcsXG4gICAgcmFuZ2UsXG4gIH07XG59XG4iXX0=